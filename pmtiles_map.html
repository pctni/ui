<!DOCTYPE html>
<html>
<head>
    <title>Route Network Map</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- MapLibre GL CSS -->
    <link rel="stylesheet" href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" />
    
    <!-- MapLibre GL JS -->
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    
    <!-- PMTiles -->
    <script src="https://unpkg.com/pmtiles@3.0.6/dist/pmtiles.js"></script>
    
    <style>
        body, html {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        #map {
            height: 100vh;
            width: 100%;
        }
    </style>
</head>
<body>
    <div id="map"></div>

    <script>
        console.log('Starting PMTiles map initialization...');
        
        // Initialize PMTiles protocol
        let protocol = new pmtiles.Protocol();
        maplibregl.addProtocol("pmtiles", protocol.tile);
        console.log('PMTiles protocol registered');

        // Get the current page URL to build absolute paths
        const currentUrl = window.location.href;
        const baseUrl = currentUrl.substring(0, currentUrl.lastIndexOf('/') + 1);
        console.log('Base URL:', baseUrl);
        console.log('Current URL:', currentUrl);
        
        // Initialize map with Esri WorldGrayCanvas
        const map = new maplibregl.Map({
            container: 'map',
            style: {
                version: 8,
                sources: {
                    'esri-gray': {
                        type: 'raster',
                        tiles: [
                            'https://services.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}'
                        ],
                        tileSize: 256,
                        attribution: '¬© Esri'
                    }
                },
                layers: [
                    {
                        id: 'esri-gray',
                        type: 'raster',
                        source: 'esri-gray'
                    }
                ]
            },
            center: [-6.5, 54.6],
            zoom: 8
        });

        let activeLayerId = null;  // e.g., 'route-network-fast'
        let activeLayerName = null; // e.g., 'route-network-fast-route_network_fastest'
        let currentTab = 'route-network';
        let currentNetworkType = 'fast';

        async function inspectAndLoad() {
            console.log('--- Running Diagnostics ---');
            await inspectPMTiles();
            console.log('--- Diagnostics Complete ---');

            // Now, show the initial layer
            const initialCheckbox = window.parent.document.getElementById('show-layer-route');
            if (initialCheckbox && initialCheckbox.checked) {
                addLayer('route-network-fast');
            }
        }

        async function inspectPMTiles() {
            console.log('üîç Inspecting PMTiles Data Fields...');
            const files = {
                'route_network_fastest_2025-06.pmtiles': 'Route Network (Fast)',
                'route_network_quietest_2025-06.pmtiles': 'Route Network (Quiet)',
                'corenet_network_ni_2025-06.pmtiles': 'Coherent Network',
                'gap_map_2025-06.pmtiles': 'Gap Analysis'
            };
            for (const [file, name] of Object.entries(files)) {
                try {
                    const p = new pmtiles.PMTiles(file);
                    const metadata = await p.getMetadata();
                     if (metadata && metadata.vector_layers) {
                        const layerInfo = metadata.vector_layers;
                        console.log(`--- ${name} ---`);
                        layerInfo.forEach(l => {
                            console.log(`  Layer Name: "${l.id}"`);
                            console.log(`  Available Fields for styling:`, Object.keys(l.fields));
                        });
                        console.log('--------------------');
                    } else {
                        console.log(`No vector_layers metadata found for ${file}`);
                    }
                } catch (error) {
                    console.error(`‚ùå Error inspecting ${file}:`, error);
                }
            }
        }

        map.on('load', () => {
            console.log('Map loaded successfully');
            map.fitBounds([
                [-8.2, 53.9], // Southwest
                [-5.4, 55.3]  // Northeast
            ]);
            // Show the initial layer by default if its checkbox is checked
            const initialCheckbox = window.parent.document.getElementById('show-layer-route');
            if (initialCheckbox && initialCheckbox.checked) {
                addLayer('route-network-fast');
            }
        });

        function addLayer(layerId) {
            if (!layerId) return;

            // Clean up previous layer and source first
            removeCurrentLayer();
            
            console.log(`üéØ Attempting to add layer: ${layerId}`);
            activeLayerId = layerId;

            let sourceConfig, sourceLayerOptions;
            
            switch(layerId) {
                case 'route-network-fast':
                    sourceConfig = { type: 'vector', url: 'pmtiles://route_network_fastest_2025-06.pmtiles' };
                    sourceLayerOptions = ['route_network_fastest_2025-06', 'route_network_fastest'];
                    break;
                case 'route-network-quiet':
                    sourceConfig = { type: 'vector', url: 'pmtiles://route_network_quietest_2025-06.pmtiles' };
                    sourceLayerOptions = ['route_network_quietest_2025-06', 'route_network_quietest'];
                    break;
                case 'coherent-network':
                    sourceConfig = { type: 'vector', url: 'pmtiles://corenet_network_ni_2025-06.pmtiles' };
                    sourceLayerOptions = ['corenet_network_ni_2025-06', 'corenet_network_ni'];
                    break;
                case 'gap-analysis':
                    sourceConfig = { type: 'vector', url: 'pmtiles://gap_map_2025-06.pmtiles' };
                    sourceLayerOptions = ['gap_map_2025-06', 'gap_map'];
                    break;
                default:
                    console.error(`Unknown layer ID: ${layerId}`);
                    return;
            }

            if (!map.getSource(activeLayerId)) {
                console.log(`Adding source for ${activeLayerId}:`, sourceConfig);
                map.addSource(activeLayerId, sourceConfig);
            }

            let layerAdded = false;
            for (const sourceLayer of sourceLayerOptions) {
                if (layerAdded) break;
                
                try {
                    console.log(`Trying source-layer: ${sourceLayer} for ${activeLayerId}`);
                    
                    let paintProps;
                    switch(activeLayerId) {
                        case 'route-network-fast':
                            paintProps = {
                                'line-color': [ 'interpolate', ['linear'], ['get', 'all_fastest_bicycle_go_dutch'], 1, '#808080', 50, '#ffff80', 100, '#80ff80', 250, '#80ffff', 500, '#8080ff', 1000, '#0000ff', 2000, '#8000ff', 3000, '#ff00ff' ],
                                'line-width': [ 'interpolate', ['linear'], ['zoom'], 8, 3, 12, 5, 16, 8 ], 'line-opacity': 0.8
                            };
                            break;
                        case 'route-network-quiet':
                            paintProps = {
                                'line-color': [ 'interpolate', ['linear'], ['get', 'all_quietest_bicycle_go_dutch'], 1, '#808080', 50, '#ffff80', 100, '#80ff80', 250, '#80ffff', 500, '#8080ff', 1000, '#0000ff', 2000, '#8000ff', 3000, '#ff00ff' ],
                                'line-width': [ 'interpolate', ['linear'], ['zoom'], 8, 3, 12, 5, 16, 8 ], 'line-opacity': 0.8
                            };
                            break;
                        case 'coherent-network':
                            paintProps = {
                                'line-color': [
                                    'match',
                                    ['get', 'cycle_potential_category'],
                                    'Primary', '#de3163',
                                    'Secondary', '#ffbf00',
                                    '#cccccc' // Default color
                                ],
                                'line-width': [ 'interpolate', ['linear'], ['zoom'], 8, 3, 12, 5, 16, 8 ], 'line-opacity': 0.8
                            };
                            break;
                        case 'gap-analysis':
                            paintProps = {
                                 'line-color': [
                                    'match',
                                    ['get', 'gap_priority'],
                                    'Critical Gap', '#ff0000',
                                    'High Priority Gap', '#ff8000',
                                    'Medium Priority Gap', '#ffff00',
                                    'No Gap', '#cccccc', // Light Gray for No Gap
                                    'rgba(0, 0, 0, 0)' // Make other values transparent
                                ],
                                 'line-width': [
                                    'case',
                                    ['==', ['get', 'gap_priority'], 'No Gap'],
                                    1, // Thinner width for No Gap
                                    3  // Default width for other gaps
                                 ], 
                                 'line-opacity': 0.8
                            };
                            break;
                        default:
                            paintProps = { 'line-color': '#000000', 'line-width': 2 };
                    }
                    
                    activeLayerName = `${activeLayerId}-${sourceLayer}`;

                    map.addLayer({
                        id: activeLayerName,
                        type: 'line',
                        source: activeLayerId,
                        'source-layer': sourceLayer,
                        paint: paintProps
                    });

                    layerAdded = true;
                    console.log(`‚úÖ Successfully added layer: ${activeLayerName}`);

                    map.on('click', activeLayerName, (e) => {
                        console.log('Feature clicked:', e.features[0].properties);
                        new maplibregl.Popup().setLngLat(e.lngLat).setHTML(`<div><strong>Properties:</strong><br>${Object.entries(e.features[0].properties).map(([k,v])=>`${k}: ${v}`).join('<br>')}</div>`).addTo(map);
                    });

                    map.on('mouseenter', activeLayerName, () => { map.getCanvas().style.cursor = 'pointer'; });
                    map.on('mouseleave', activeLayerName, () => { map.getCanvas().style.cursor = ''; });

                } catch (error) {
                    console.warn(`Failed to add layer with source-layer ${sourceLayer}:`, error.message);
                    if (map.getLayer(`${activeLayerId}-${sourceLayer}`)) {
                        map.removeLayer(`${activeLayerId}-${sourceLayer}`);
                    }
                }
            }
        }

        function removeCurrentLayer() {
            if (activeLayerName && map.getLayer(activeLayerName)) {
                console.log(`Removing current layer: ${activeLayerName}`);
                map.removeLayer(activeLayerName);
            }
            if (activeLayerId && map.getSource(activeLayerId)) {
                console.log(`Removing current source: ${activeLayerId}`);
                map.removeSource(activeLayerId);
            }
            activeLayerId = null;
            activeLayerName = null;
        }

        window.addEventListener('message', (event) => {
            const { type, layer, show, networkType } = event.data;
            if (!type) return;

            switch (type) {
                case 'switchLayer':
                    currentTab = layer;
                    const checkboxId = `show-layer-${currentTab.split('-')[0]}`;
                    const isChecked = window.parent.document.getElementById(checkboxId)?.checked;
                    if (isChecked) {
                        let layerId = currentTab === 'route-network' ? `${currentTab}-${currentNetworkType}` : currentTab;
                        addLayer(layerId);
                    } else {
                        removeCurrentLayer();
                    }
                    break;
                case 'toggleLayer':
                    if (show) {
                        let layerId = currentTab === 'route-network' ? `${currentTab}-${currentNetworkType}` : currentTab;
                        addLayer(layerId);
                    } else {
                        removeCurrentLayer();
                    }
                    break;
                case 'changeNetworkType':
                    currentNetworkType = networkType;
                    const routeCheckbox = window.parent.document.getElementById('show-layer-route');
                    if (currentTab === 'route-network' && routeCheckbox?.checked) {
                        addLayer(`route-network-${currentNetworkType}`);
                    }
                    break;
            }
        });

        // Enhanced error handling
        map.on('error', (e) => {
            console.error('üö® Map error:', e);
        });

        map.on('sourcedata', (e) => {
            if (e.isSourceLoaded) {
                console.log(`üìä Source loaded: ${e.sourceId}`);
            }
            if (e.sourceDataType === 'metadata') {
                console.log(`üìã Source metadata loaded: ${e.sourceId}`);
            }
        });

        map.on('data', (e) => {
            if (e.dataType === 'source' && e.isSourceLoaded) {
                console.log(`üìÅ Data loaded for source: ${e.sourceId}`);
            }
        });
    </script>
</body>
</html> 